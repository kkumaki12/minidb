/*
Package btree はB+木インデックスを提供する。

# 概要

B+木はデータベースで最も一般的に使われるインデックス構造。
キーでソートされたデータに対して効率的な検索・挿入・範囲検索を提供する。

# B+木の特徴

  - 全てのデータはリーフノードに格納される
  - ブランチノードはキーと子へのポインタのみを持つ
  - リーフノードは双方向リンクリストで接続されている（範囲検索用）
  - 木は常にバランスが保たれる（全てのリーフは同じ深さ）

	                    [Branch: 50]
	                   /            \
	        [Branch: 20,30]      [Branch: 70,90]
	        /     |     \        /     |      \
	    [Leaf] [Leaf] [Leaf]  [Leaf] [Leaf] [Leaf]
	      ↔      ↔      ↔       ↔      ↔
	    (リーフノードは双方向リンクで接続)

# ノードの種類

Leaf（リーフノード）:
  - 実際のキー・値ペアを格納する
  - 前後のリーフへのポインタを持つ
  - スロットページ形式でデータを管理

Branch（ブランチノード）:
  - キーと子ページへのポインタを持つ
  - n個のキーに対してn+1個の子ポインタ
  - 検索時の経路案内役

Meta（メタページ）:
  - ルートページIDを保持
  - B-tree全体の情報を管理

# スロットページ形式

ページ内のデータ管理にはスロットページ形式を採用：

	┌──────────────────────────────────────────┐
	│ Header                                    │
	├──────────────────────────────────────────┤
	│ Slot[0] Slot[1] Slot[2] ...    →        │
	│                                          │
	│        ← ... Data[2] Data[1] Data[0]    │
	└──────────────────────────────────────────┘

  - ヘッダー: ペア数、空き領域オフセットなど
  - スロット配列: 各データへのオフセット（先頭から後方へ伸びる）
  - データ領域: 実際のキー・値（末尾から前方へ伸びる）
  - 可変長データを効率的に格納できる

# 検索アルゴリズム

1. メタページからルートページIDを取得
2. ルートから開始し、ブランチノードを辿る
3. 各ブランチで二分探索し、適切な子を選択
4. リーフノードに到達したら二分探索でキーを探す

# 挿入アルゴリズム

1. 検索と同様にリーフノードを見つける
2. リーフにスペースがあれば挿入
3. スペースがなければ分割（split）:
   - 新しいリーフを作成
   - データを半分ずつ分ける
   - 親ブランチに新しいキーと子ポインタを追加
4. ブランチも満杯なら再帰的に分割
5. ルートが分割されたら新しいルートを作成

# 使用例

	// B-treeを作成
	tree, _ := btree.Create(bufmgr)

	// キー・値を挿入
	tree.Insert(bufmgr, []byte("key1"), []byte("value1"))
	tree.Insert(bufmgr, []byte("key2"), []byte("value2"))

	// 検索（イテレータを取得）
	iter, _ := tree.Search(bufmgr, btree.NewSearchKey([]byte("key1")))
	for {
	    pair, _ := iter.Next(bufmgr)
	    if pair == nil {
	        break
	    }
	    fmt.Printf("%s: %s\n", pair.Key, pair.Value)
	}

	// 範囲検索（先頭から）
	iter, _ = tree.Search(bufmgr, btree.NewSearchStart())
*/
package btree
